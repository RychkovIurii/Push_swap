# Push_swap - Sorting Algorithm
## Overview
The Push_swap project aims to implement sorting algorithms in C, using only two stacks (`a` and `b`) to sort a set of integers. It focuses on optimizing the number of operations needed to sort the list, demonstrating an understanding of algorithmic complexity, and implementing basic data structures and operations.  
Sort data on a stack with a limited set of instructions, using the lowest possible number of actions.  
I manipulate various types of algorithms and choose the most appropriate solution (out of many) for an optimized data sorting.  

## Table of Contents
- [Project Details](#project-details)
- [What I Learned](#what-i-learned)
- [Introduction](#introduction)
- [Main Features](#main-features)
- [Challenges](#challenges)
- [Allowed Functions](#allowed-functions)
- [My Approach](#my-approach)
- [Mandatory Part](#mandatory-part)
- [Bonus Part](#bonus-part)
- [How to Run](#how-to-run)
- [Performance](#performance)

---

## Project Details
- **Total Time Spent**: 17 days
- **Total Lines of Code**: 724
- **Commts**: 39
- **Programming Language**: C


---

## What I Learned
- Implementing sorting algorithms with limited operations helps improve understanding of algorithmic complexity and data structures.
- Working with stacks (`a` and `b`) enhances problem-solving skills when constrained to a specific set of instructions.
- The project reinforced the importance of optimizing operations and code readability for performance.

---

## Introduction
The objective of the Push_swap project is to implement sorting algorithms in C. Using only two stacks, `a` and `b`, the goal is to sort a list of integers with the fewest operations possible. The program must perform the sorting by utilizing the following operations:  
- `sa` and `sb` (swap)
- `pa` and `pb` (push)
- `ra` and `rb` (rotate)
- `rra` and `rrb` (reverse rotate)
- `rr` and `rrr` (combined operations)

These operations must be used in such a way that the list is sorted optimally in the fewest steps.


---

## Main Features
### Mandatory Part:
- Implement sorting algorithms for small and large datasets with the least number of operations.
- Handle input parsing, error handling, and stack manipulations (push, pop, swap, rotate).
- Optimize sorting based on input size and conditions (for example, use different algorithms for small stacks vs large stacks).

### Bonus Part:
- The bonus task involves creating a `checker` program to verify that the list of instructions generated by the `push_swap` program correctly sorts the stack.
---


## Challenges
- Finding the right balance between performance and readability was challenging.
- Implementing an optimized sorting algorithm that works well for both small and large datasets.
- Handling edge cases and ensuring robustness.

---

## Allowed Functions

read, write, malloc, free, exit, ft_printf.

---

## My Approach

For this project, I experimented with multiple approaches to find an optimal solution for sorting data in the most efficient manner possible.

1. **Brute Force for Small Numbers**:  
   For smaller sets of numbers, I started by applying a brute-force approach for each number. This method directly sorts the stack by performing swaps and rotations until the stack is sorted. Save only amount of operations and list of operations. Although this approach is less efficient, it works well for small datasets.

2. **Turk Algorithm for Large Numbers**:  
   When dealing with larger datasets, I turned to the Turk algorithm, which is designed to handle larger inputs efficiently. This algorithm reduces the overall time complexity compared to brute force and is more suitable for sorting larger numbers. I found it a bit complex and decided do it in a shorter way.

3. **Push to `b` and Cost Calculation**:  
   After experimenting with different methods, I decided on a strategy where I push every number from stack `a` to stack `b`. Once only three numbers remain in `a`, I calculate the "cost" for each number (i.e., the number of operations it takes to move it back to `a` in the correct order). I then push the cheapest number back to `a`.  
   This method gives a good balance between simplicity, performance, and code readability. It allows me to keep the sorting process clear and efficient, with easy-to-follow logic.

---

## Mandatory Part

### Requirements:
- Implement the sorting algorithm using the provided operations with minimal instruction usage.
- Handle integer input, ensuring there are no duplicates or invalid values.
- Provide a program that correctly sorts data using the least number of operations, with input handling and proper error checking.

---

## Bonus Part

### Checker Program

The bonus part involves creating a `checker` program, which verifies whether the instructions generated by the `push_swap` program actually sort the stack properly.

#### Requirements:

- **Program name**: `checker`
- **Arguments**: Stack `a` (a list of integers). The first argument should be at the top of the stack (be careful about the order).
- **External Functions**: `read`, `write`, `malloc`, `free`, `exit`, `ft_printf`, and any equivalent you coded yourself.
- **Libft**: Authorized.

#### Description:

- The program reads the stack `a` as input, and waits for instructions on the standard input. Each instruction is followed by a newline (`\n`).
- Once all instructions are read, the program will execute them on the stack received as an argument.
- If, after executing the instructions, stack `a` is sorted and stack `b` is empty, the program will print `"OK"` followed by a newline.
- If the stacks are not sorted or stack `b` is not empty, the program will print `"KO"` followed by a newline.
- In case of an error (e.g., invalid instructions or arguments), it will print `"Error"` followed by a newline.

#### Example:

```bash
$> ./checker 3 2 1 0
rra
pb
sa
rra
pa
OK
```

---

## How to Run
Clone the repository:

```bash
git clone https://github.com/RychkovIurii/Push_swap.git
```

Navigate to the project folder:
```bash
cd Push_swap
```
Compile the project using the Makefile:
```bash
make
```
Run the mandatory part:
```bash
./push_swap 3 2 1
```
This will sort the numbers 3 2 1 in ascending order.

Run the bonus part:
```bash
./checker 3 2 1 "sa" "ra"
```
This will check if the sequence of operations (sa, ra) results in a sorted list.

## Performance
The algorithm performs well across a wide range of input sizes, from small datasets to larger ones. 
By using a combination of bublesort for small numbers and my algorithm for larger sets, the solution efficiently handles both extremes while maintaining readability and simplicity.
